[["index.html", "Interactive maps with leaflet Chapter 1 Prerequisites", " Interactive maps with leaflet Rex Parsons 2022-05-23 Chapter 1 Prerequisites This book is intended as a non-comprehensive guide to developing interactive maps with leaflet and shiny. This is by no means comprehensive as it is based on methods that were used in developing theiTRAQI shiny app. However, since this book does focus on the applied problem of developing the iTRAQI shiny app, it includes specific help and methods for these are described here that may be otherwise difficult to find. For a more comprehensive introduction to leaflet, see the leaflet documentation. For a more comprehensive introduction to shiny, see the Mastering Shiny book "],["intro.html", "Chapter 2 Introduction 2.1 leaflet layers", " Chapter 2 Introduction This book focuses on using leaflet and shiny together to make interactive maps. Heres a simple leaflet map. library(leaflet) leaflet() %&gt;% addTiles() %&gt;% # Add default OpenStreetMap map tiles addMarkers(lng=174.768, lat=-36.852, popup=&quot;The birthplace of R&quot;) Figure 2.1: Simple leaflet map Before we begin adding to this map, we need to create the layers that we want to add. In the iTRAQI app, we used markers, rasters and polygons to show the key locations and interpolations. See the iTRAQI shiny app here and read more about it in the information tab of the app. Chapter 3 will focus on these first steps, before making any maps or interactivity. If youre already well-versed in making these layers and the sf R package, you can skip to the latter chapters. 2.1 leaflet layers To display statistical area level 1 and 2 (SA1 and SA2) regions on the map, we will be using sf objects with MULTIPOLYGON geometries. These are multipolygons because some of these areas include distinct areas, such as a set of islands, that arent contained within a single polygon. To display the location of acute and rehab centers and town locations with travel times that we used for interpolations, we used (spatial) data.frames that had longitudes and latitudes for their location. To display the continuous interpolations, we used RasterLayer objects. Using a polygon and raster layer thats used in the iTRAQI map and some markers in a data.frame, we can make see the basic approach that we use to display these on a leaflet map. First, lets make a data.frame with the coordinates for the Princess Alexandra and Townsville University Hospitals, and download a raster and polygon layer from the iTRAQI app GitHub repository. library(tidyverse) library(sf) download_layer &lt;- function(layer_name, save_dir=&quot;input&quot;) { githubURL &lt;- glue::glue(&quot;https://raw.githubusercontent.com/RWParsons/iTRAQI_app/main/input/layers/{layer_name}&quot;) download.file(githubURL, file.path(save_dir, layer_name), method=&quot;curl&quot;) readRDS(file.path(save_dir, layer_name)) } raster_layer &lt;- download_layer(&quot;rehab_raster.rds&quot;) %&gt;% raster::raster(., layer=1) polygons_layer &lt;- download_layer(&quot;stacked_SA1_and_SA2_polygons_year2016_simplified.rds&quot;) polygons_layer &lt;- polygons_layer[polygons_layer$SA_level==2, ] # show SA2 regions for example marker_locations &lt;- data.frame( centre_name=c(&quot;Princess Alexandra Hospital (PAH)&quot;, &quot;Townsville University Hospital&quot;), x=c(153.033519, 146.762041), y=c(-27.497374, -19.320502) ) Here, in figure 2.2, we make a leaflet map with the three object types. We will use these three functions, addPolygons(), addRasterImage(), and addMarkers() to add almost all of the content to our leaflet maps. leaflet() %&gt;% addProviderTiles(&quot;CartoDB.VoyagerNoLabels&quot;) %&gt;% # add a simple base map addPolygons( data=polygons_layer, fillColor=&quot;Orange&quot;, color=&quot;black&quot;, weight=1, group=&quot;Polygons&quot; ) %&gt;% addRasterImage( x=raster_layer, colors=&quot;YlOrRd&quot;, group=&quot;Raster&quot; ) %&gt;% addMarkers( lng=marker_locations$x, lat=marker_locations$y, label=marker_locations$centre_name, group=&quot;Points&quot; ) %&gt;% addLayersControl( position=&quot;topright&quot;, baseGroups=c(&quot;Polygons&quot;, &quot;Raster&quot;, &quot;Points&quot;), options=layersControlOptions(collapsed = FALSE) ) Figure 2.2: leaflet map with polygons, rasters and markers Almost all of these objects were made before being used in the shiny app. Chapter 3 will introduce the methods used to make them. Chapter 4 will introduce the basics of a shiny app. Chapter 5 will introduce the more specific methods that were used to construct the iTRAQI app itself. "],["building.html", "Chapter 3 Creating the layers 3.1 Kriging 3.2 Polygons and aggregations", " Chapter 3 Creating the layers This chapter will cover the necessary steps to make layers which will be visualised in the app: kriging spatial joins aggregating interpolations within polygons 3.1 Kriging Kriging is an interpolation method that we use for iTRAQI. We pass observed values with known outcomes and coordinates and use kriging to get predicted values for new coordinates (the rest of Queensland). 3.1.1 Data First, we will download the data that we used for acute care travel time. Each row in the data has a coordinate (x,y) and outcome that we will be using for interpolation (time) Table 3.1 and figure 3.1 show a preview of the data that we will be using. library(tidyverse) library(leaflet) save_dir &lt;- &quot;input&quot; githubURL &lt;- glue::glue(&quot;https://raw.githubusercontent.com/RWParsons/iTRAQI_app/main/input/QLD_locations_with_RSQ_times_20220518.csv&quot;) download.file(githubURL, file.path(save_dir, &quot;df_acute.csv&quot;), method=&quot;curl&quot;) df_acute &lt;- read.csv(file.path(save_dir, &quot;df_acute.csv&quot;)) %&gt;% select(location, x, y, centre=acute_care_centre, time=acute_time) knitr::kable( head(df_acute, 10), caption = &#39;A preview of the data used for kriging&#39;, booktabs = TRUE ) Table 3.1: A preview of the data used for kriging location x y centre time Wallangarra 151.9262 -28.92345 Brisbane (PAH/RBWH) 195 Texas 151.1692 -28.85306 Brisbane (PAH/RBWH) 195 Smithfield 145.6902 -16.83142 Townsville University Hospital 183 Johnstone 148.5382 -28.67870 Brisbane (PAH/RBWH) 345 Stanthorpe 151.9327 -28.65779 Brisbane (PAH/RBWH) 170 Dirranbandi 148.2271 -28.58410 Brisbane (PAH/RBWH) 345 Yelarbon 150.7524 -28.57416 Brisbane (PAH/RBWH) 216 Goondiwindi 150.3062 -28.54799 Brisbane (PAH/RBWH) 216 Inglewood 151.0795 -28.41751 Brisbane (PAH/RBWH) 183 Killarney 152.2963 -28.33305 Brisbane (PAH/RBWH) 149 leaflet() %&gt;% addProviderTiles(&quot;CartoDB.VoyagerNoLabels&quot;) %&gt;% addCircleMarkers( lng=df_acute$x, lat=df_acute$y, popup=glue::glue( # customise your popups with html tags &quot;&lt;b&gt;Location: &lt;/b&gt;{df_acute$location}&lt;br&gt;&quot;, &quot;&lt;b&gt;Time to acute care (minutes): &lt;/b&gt;{df_acute$time}&quot;), radius=2, fillOpacity=0, ) Figure 3.1: leaflet map with locations We will convert our data.frame into a spatial data.frame and load the gstat package as we will be using it for the kriging (gstat::krige()). library(sp) library(gstat) ## Warning: package &#39;gstat&#39; was built under R version 4.1.2 library(sf) coordinates(df_acute) &lt;- ~ x + y 3.1.2 Making a grid of values for interpolation Another key ingredient to do kriging is to have a grid of coordinates for which we want predictions (QLD). The code below achieves this by creating a grid across all coordinates of QLD and keeping only those which intersect with the QLD boundary polygon. The initial grid contains coordinates for all combinations of latitudes and longitudes in QLD (which includes a lot of water of the north east for which we dont need interpolated values). Figure 3.2 shows the initial grid made using sp::makegrid() in blue and the intersect between this and the QLD boundary in orange. We will use the values which are within the QLD boundary for kriging. The cellsize we use here is large to save computation time (and to highlight a problem that we will come across very soon). This controls the resolution of the interpolation - the smaller the cellsize, the greater the spatial resolution. This is in degrees units (0.1 degree = 11.1km) so only having one prediction for every 11.1kmÂ² in QLD may mean that we miss out on some valuable information! aus &lt;- raster::getData(&#39;GADM&#39;, path=&quot;input&quot;, country = &#39;AUS&#39;, level = 1) qld_boundary &lt;- aus[aus$NAME_1 == &quot;Queensland&quot;,] qld_boundary_sf &lt;- st_as_sfc(qld_boundary) cellsize &lt;- 0.05 grid &lt;- makegrid(qld_boundary, cellsize = cellsize) pnts_sf &lt;- st_as_sf(grid, coords = c(&#39;x1&#39;, &#39;x2&#39;), crs = st_crs(qld_boundary)) pnts_in_qld &lt;- st_intersection(pnts_sf, qld_boundary_sf) %&gt;% st_coordinates() %&gt;% as.data.frame() ggplot() + geom_point(data=grid, aes(x1, x2), col=&quot;blue&quot;) + geom_point(data=pnts_in_qld, aes(X, Y), col=&quot;orange&quot;) + coord_equal() + labs( x=&quot;Longitude&quot;, y=&quot;Latitude&quot; ) Figure 3.2: coordinates that we will use for kriging (initial grid in blue and those than intersect with QLD boundary in orange) 3.1.3 Kriging (finally) Now we are ready to do the kriging. gstat::krige() requires that the newdata be of class Spatial, sf, or stars. Here, I specify the coordinates using sp::coordinates(). It also requires that you specify the variogram model within - here we use a circular model vgm(\"Cir\") but there may be better choices for other data. Figure 3.3 shows the map with the interpolated values from kriging. lzn_vgm &lt;- variogram(time ~ 1, df_acute) lzn_fit &lt;- fit.variogram(lzn_vgm, model=vgm(&quot;Sph&quot;)) coordinates(pnts_in_qld) &lt;- ~ X + Y kriged_layer &lt;- krige( formula=time ~ 1, locations=df_acute, newdata=pnts_in_qld, model=lzn_fit ) %&gt;% as.data.frame() ## [using ordinary kriging] ggplot(data=kriged_layer, aes(X, Y, col=var1.pred)) + geom_point() + scale_colour_gradientn(colors=c(&quot;yellow&quot;, &quot;orange&quot;, &quot;red&quot;, &quot;black&quot;)) + coord_equal() + labs( x=&quot;Longitude&quot;, y=&quot;Latitude&quot; ) Figure 3.3: coordinates that we will use for kriging (initial grid in blue and those than intersect with QLD boundary in orange) 3.1.4 Making rasters Now we can turn our grid of interpolated values into the rasters that we can then use in a leaflet map. We use the raster package. Figure ?? shows our kriged output as a raster on a leaflet map, the same type of objects as whats used in iTRAQI. raster_layer &lt;- raster::rasterFromXYZ(kriged_layer, crs=4326, res=0.05) raster_layer &lt;- raster::raster(raster_layer, layer=1) # layer=1 to select the prediction values rather than the variance leaflet() %&gt;% addProviderTiles(&quot;CartoDB.VoyagerNoLabels&quot;) %&gt;% addRasterImage(x=raster_layer, colors=&quot;YlOrRd&quot;) Figure 3.4: coordinates that we will use for kriging (initial grid in blue and those than intersect with QLD boundary in orange) 3.2 Polygons and aggregations "],["shiny-intro.html", "Chapter 4 An app with a map", " Chapter 4 An app with a map This chapter will have a brief intro to shiny with a map: ui and server reactivity leaflet leafletproxy "],["shiny-methods.html", "Chapter 5 An app with a map", " Chapter 5 An app with a map This chapter will have a brief intro to shiny with a map: ui and server reactivity leaflet leafletproxy "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
