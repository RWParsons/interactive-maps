[["leaflet-colours.html", "Chapter 6 Colours with leaflet 6.1 Colour scales with leaflet", " Chapter 6 Colours with leaflet This chapter will cover: colour palettes for leaflet continuous discrete a mix (?) legends in leaflet 6.1 Colour scales with leaflet For these examples, we will use the polygons and rasters from iTRAQI. The following chunk downloads these layers (just the same as in chapter 1 but using SA1s this time). library(tidyverse) library(sf) download_layer &lt;- function(layer_name, save_dir=&quot;input&quot;) { githubURL &lt;- glue::glue(&quot;https://raw.githubusercontent.com/RWParsons/iTRAQI_app/main/input/layers/{layer_name}&quot;) download.file(githubURL, file.path(save_dir, layer_name), method=&quot;curl&quot;) readRDS(file.path(save_dir, layer_name)) } raster_layer &lt;- download_layer(&quot;rehab_raster.rds&quot;) %&gt;% raster::raster(., layer=1) polygons_layer &lt;- download_layer(&quot;stacked_SA1_and_SA2_polygons_year2016_simplified.rds&quot;) 6.1.1 Palettes for discrete variables For discrete/factor variables, we can use colorFactor to create a palette for leaflet. The example below creates a very similar map to the ABS and we use the same one in the tour tab of the iTRAQI app (except that was using SA1s rather than SA2s). palFac &lt;- colorFactor(&quot;Greens&quot;, levels=0:4, ordered=TRUE, reverse=TRUE) leaflet() %&gt;% addTiles() %&gt;% addPolygons( data=polygons_layer[polygons_layer$SA_level==2, ], color=&quot;black&quot;, weight=1, fillOpacity=1, fillColor=palFac(polygons_layer[polygons_layer$SA_level==2, ]$ra) ) In the code above, we are passing a vector of hex codes as the fillColor argument: one for each polygon. unique(palFac(polygons_layer$ra)) ## [1] &quot;#006D2C&quot; &quot;#31A354&quot; &quot;#74C476&quot; &quot;#BAE4B3&quot; &quot;#EDF8E9&quot; length(palFac(polygons_layer$ra)) == nrow(polygons_layer) ## [1] TRUE For the iTRAQI index, we used a range of colours and did this by specifying a hex code for each one specifically. First, we need to add the index to the polygons_layer. iTRAQI_acute_breaks &lt;- c(-Inf, 1, 2, 4, 6, Inf) iTRAQI_rehab_breaks &lt;- c(-Inf, 1, 2, 4, 6, Inf) get_iTRAQI_index &lt;- function(acute_mins, rehab_mins){ acute_cat &lt;- cut(acute_mins/60, breaks=iTRAQI_acute_breaks) rehab_cat &lt;- cut(rehab_mins/60, breaks=iTRAQI_rehab_breaks) acute_label &lt;- as.numeric(acute_cat) rehab_label &lt;- LETTERS[rehab_cat] index_value &lt;- paste0(acute_label, rehab_label) ifelse(index_value == &quot;NANA&quot;, NA, index_value) } polygons_layer &lt;- polygons_layer %&gt;% mutate(index=get_iTRAQI_index(value_acute, value_rehab)) # Create a copy of the polygons layer with only SA2s for faster displaying maps qld_SA2s &lt;- filter(polygons_layer, SA_level==2) Here are the colours we used for each of levels in the index. index_palette_url &lt;- RCurl::getURL(&quot;https://raw.githubusercontent.com/RWParsons/iTRAQI_app/main/input/index_palette.csv&quot;) index_palette &lt;- read.csv(text=index_palette_url) %&gt;% select(Acute, Rehab, hex=hex2) %&gt;% cbind(., iTRAQI_bins=(na.omit(unique(polygons_layer$index)) %&gt;% sort())) knitr::kable((index_palette)) Acute Rehab hex iTRAQI_bins &lt;1 A #ffe699 1A &lt;1 B #ffd966 1B 1-2 A #ffc000 2A 1-2 B #ffa700 2B 2-4 A #ff8457 3A 2-4 B #ff6600 3B 2-4 C #ff4900 3C 2-4 D #ff2f25 3D 4-6 B #e6005d 4B 4-6 C #d20055 4C 4-6 D #b00047 4D 4-6 E #8a003e 4E 6+ C #700055 5C 6+ D #420032 5D 6+ E #0d0d0d 5E No we can create the palette in the same was now as we did before with the remoteness map. paliTRAQI &lt;- colorFactor( index_palette$hex, levels=index_palette$iTRAQI_bins, ordered=FALSE ) leaflet() %&gt;% addTiles() %&gt;% addPolygons( data=qld_SA2s, color=&quot;black&quot;, weight=1, fillOpacity=1, fillColor=paliTRAQI(qld_SA2s$index) ) 6.1.2 Palettes for continuous variables For the rasters, we used continuous colour scales. leaflet() %&gt;% addTiles() %&gt;% addRasterImage( x=raster_layer ) Since the raster is a grid of values, we don’t need to pass a huge vector of hex codes, but instead we need to pass a function which can take that value and return a hex code. But still, there are options. We could use a binned colour scheme to make an isochrone type map as below. bins &lt;- c(0, 30, 60, 120, 180, 240, 300, 360, 900, 1200) palBin &lt;- colorBin(&quot;YlOrRd&quot;, domain = 0:1200, bins=bins, na.color=&quot;transparent&quot;) leaflet() %&gt;% addTiles() %&gt;% addRasterImage( x=raster_layer, colors=palBin ) ## Warning in colors(.): Some values were outside the color scale and will be ## treated as NA And our other option is to use a continuous colour scale. palNum &lt;- colorNumeric(&quot;YlOrRd&quot;, domain=0:1200, na.color=&quot;transparent&quot;) leaflet() %&gt;% addTiles() %&gt;% addRasterImage( x=raster_layer, colors=palNum ) ## Warning in colors(.): Some values were outside the color scale and will be ## treated as NA 6.1.3 A mix of continuous and discrete colour scales This may sound like an odd thing to want to do: in the iTRAQI app, you may notice that we use the same legend and colour scale for all of our time-to-care maps, and that the scale on the legend is not linear from 0 to 1200 minutes. Fortunately, we can make make a (hacky) mix of both colorbin and colorNumeric to give specified breaks to a continuous scale. (We can also display the legend as if it were the colorBin legend.) The first thing to consider is that the palette passed to colors argument doesn’t need to be made with a single palette from leaflet. Instead, we can merge many within a parent function. Here’s a smaller example. palNumLow &lt;- colorNumeric(&quot;Greens&quot;, domain=0:300) palNumHigh &lt;- colorNumeric(&quot;Reds&quot;, domain=300:1200) pal_combined &lt;- function(x) { case_when( x &lt;=300 ~ palNumLow(x), x &gt;300 ~ palNumHigh(x), TRUE ~ &quot;transparent&quot; ) } leaflet() %&gt;% addTiles() %&gt;% addRasterImage( x=raster_layer, colors=pal_combined ) ## Warning in palNumLow(x): Some values were outside the color scale and will be ## treated as NA ## Warning in palNumHigh(x): Some values were outside the color scale and will be ## treated as NA What a truly hideous colour scale! Here, we used one colour scale (“Greens”) for values between 0 and 300 minutes, and another scale (“Reds”) for values from 300 to 1200! The good thing is that we can now mix and match scales any which way we desire, and combine several numeric scales across unevenly spaced breaks to create a single, continuous palette which doesn’t get washed out due to the extremes in the domain. Note that in our drive times here, we have times from the Torres Strait which were around 1200 minutes! Using any of the sequential colour palettes would mean that the differences across most of mainland QLD would appear to be smaller than they are as we would require the domain of the palette to accomodate for these extremely large times. In the code below, we start out by using the bins that we had defined for the palBin(). We can then use the sequence of colours from the palBin, at each bin, as the end-range colours within a range of colorNumeric’s. By doing this, palNum1 is now a continuous colour scale from the first to the second level of palBin, palNum2 is a continuous scale from the second to third level of palBin…. For the last one, palNum9, we go from the deepest colour within the palBin to black. palBin &lt;- colorBin(&quot;YlOrRd&quot;, domain = min(bins):max(bins), bins=bins, na.color=&quot;transparent&quot;) palNum1 &lt;- colorNumeric(c(palBin(bins[1]), palBin(bins[2])), domain=0:30, na.color=&quot;transparent&quot;) palNum2 &lt;- colorNumeric(c(palBin(bins[2]), palBin(bins[3])), domain=30:60, na.color=&quot;transparent&quot;) palNum3 &lt;- colorNumeric(c(palBin(bins[3]), palBin(bins[4])), domain=60:120, na.color=&quot;transparent&quot;) palNum4 &lt;- colorNumeric(c(palBin(bins[4]), palBin(bins[5])), domain=120:180, na.color=&quot;transparent&quot;) palNum5 &lt;- colorNumeric(c(palBin(bins[5]), palBin(bins[6])), domain=180:240, na.color=&quot;transparent&quot;) palNum6 &lt;- colorNumeric(c(palBin(bins[6]), palBin(bins[7])), domain=240:300, na.color=&quot;transparent&quot;) palNum7 &lt;- colorNumeric(c(palBin(bins[7]), palBin(bins[8])), domain=300:360, na.color=&quot;transparent&quot;) palNum8 &lt;- colorNumeric(c(palBin(bins[8]), palBin(bins[9])), domain=360:900, na.color=&quot;transparent&quot;) palNum9 &lt;- colorNumeric(c(palBin(bins[9]), &quot;#000000&quot;), domain=900:1200, na.color=&quot;transparent&quot;) We can then combine all of these within a parent function which can then be called with any value. Since palNum9 approaches values of 1200 and blackness, all values above 1200 are black. palNumMix &lt;- function(x){ case_when( x &lt; 30 ~ palNum1(x), x &lt; 60 ~ palNum2(x), x &lt; 120 ~ palNum3(x), x &lt; 180 ~ palNum4(x), x &lt; 240 ~ palNum5(x), x &lt; 300 ~ palNum6(x), x &lt; 360 ~ palNum7(x), x &lt; 900 ~ palNum8(x), x &lt;1200 ~ palNum9(x), x &gt;=1200~ &quot;#000000&quot;, TRUE ~ &quot;transparent&quot; ) } The end result is a much more appropriate colour scale than either the binned or (the original) continuous colour scales. For iTRAQI, we used this colour scale for both the rasters and the polygons (except for the index). leaflet() %&gt;% addTiles() %&gt;% addRasterImage( x=raster_layer, colors=palNumMix ) leaflet() %&gt;% addTiles() %&gt;% addPolygons( data=qld_SA2s, color=&quot;black&quot;, weight=1, fillOpacity=1, fillColor=palNumMix(qld_SA2s$value_rehab) ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
