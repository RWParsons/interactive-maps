[["colour-palettes.html", "Chapter 6 All things colourful 6.1 leaflet colours", " Chapter 6 All things colourful This chapter will cover: colour palettes for leaflet continuous discrete a mix (?) legends in leaflet matching ggplot2 colour scales to the leaflet colour palettes putting it all together in the shiny app reactive display of legends pairing your ggplot scales to your map 6.1 leaflet colours For these examples, we will use the polygons and rasters from iTRAQI. The following chunk downloads these layers (just the same as in chapter 1 but using SA1s this time). library(tidyverse) library(sf) download_layer &lt;- function(layer_name, save_dir=&quot;input&quot;) { githubURL &lt;- glue::glue(&quot;https://raw.githubusercontent.com/RWParsons/iTRAQI_app/main/input/layers/{layer_name}&quot;) download.file(githubURL, file.path(save_dir, layer_name), method=&quot;curl&quot;) readRDS(file.path(save_dir, layer_name)) } raster_layer &lt;- download_layer(&quot;rehab_raster.rds&quot;) %&gt;% raster::raster(., layer=1) polygons_layer &lt;- download_layer(&quot;stacked_SA1_and_SA2_polygons_year2016_simplified.rds&quot;) 6.1.1 Palettes for discrete variables For discrete/factor variables, we can use colorFactor to create a palette for leaflet. The example below creates a very similar map to the ABS and we use the same one in the tour tab of the iTRAQI app (except that was using SA1s rather than SA2s). palFac &lt;- colorFactor(&quot;Greens&quot;, levels=0:4, ordered=TRUE, reverse=TRUE) leaflet() %&gt;% addTiles() %&gt;% addPolygons( data=polygons_layer[polygons_layer$SA_level==2, ], color=&quot;black&quot;, weight=1, fillOpacity=1, fillColor=palFac(polygons_layer[polygons_layer$SA_level==2, ]$ra) ) In the code above, we are passing a vector of hex codes as the fillColor argument: one for each polygon. unique(palFac(polygons_layer$ra)) ## [1] &quot;#006D2C&quot; &quot;#31A354&quot; &quot;#74C476&quot; &quot;#BAE4B3&quot; &quot;#EDF8E9&quot; length(palFac(polygons_layer$ra)) == nrow(polygons_layer) ## [1] TRUE For the iTRAQI index, we used a range of colours and did this by specifying a hex code for each one specifically. First, we need to add the index to the polygons_layer. iTRAQI_acute_breaks &lt;- c(-Inf, 1, 2, 4, 6, Inf) iTRAQI_rehab_breaks &lt;- c(-Inf, 1, 2, 4, 6, Inf) get_iTRAQI_index &lt;- function(acute_mins, rehab_mins){ acute_cat &lt;- cut(acute_mins/60, breaks=iTRAQI_acute_breaks) rehab_cat &lt;- cut(rehab_mins/60, breaks=iTRAQI_rehab_breaks) acute_label &lt;- as.numeric(acute_cat) rehab_label &lt;- LETTERS[rehab_cat] index_value &lt;- paste0(acute_label, rehab_label) ifelse(index_value == &quot;NANA&quot;, NA, index_value) } polygons_layer &lt;- polygons_layer %&gt;% mutate(index=get_iTRAQI_index(value_acute, value_rehab)) # Create a copy of the polygons layer with only SA2s for faster displaying maps qld_SA2s &lt;- filter(polygons_layer, SA_level==2) Here are the colours we used for each of levels in the index . index_palette_url &lt;- RCurl::getURL(&quot;https://raw.githubusercontent.com/RWParsons/iTRAQI_app/main/input/index_palette.csv&quot;) index_palette &lt;- read.csv(text=index_palette_url) %&gt;% select(Acute, Rehab, hex=hex2) %&gt;% cbind(., iTRAQI_bins=(na.omit(unique(polygons_layer$index)) %&gt;% sort())) knitr::kable((index_palette)) Acute Rehab hex iTRAQI_bins &lt;1 A #ffe699 1A &lt;1 B #ffd966 1B 1-2 A #ffc000 2A 1-2 B #ffa700 2B 2-4 A #ff8457 3A 2-4 B #ff6600 3B 2-4 C #ff4900 3C 2-4 D #ff2f25 3D 4-6 B #e6005d 4B 4-6 C #d20055 4C 4-6 D #b00047 4D 4-6 E #8a003e 4E 6+ C #700055 5C 6+ D #420032 5D 6+ E #0d0d0d 5E No we can create the palette in the same was now as we did before with the remoteness map. paliTRAQI &lt;- colorFactor( index_palette$hex, levels=iTRAQI_bins, ordered=FALSE ) leaflet() %&gt;% addTiles() %&gt;% addPolygons( data=qld_SA2s, color=&quot;black&quot;, weight=1, fillOpacity=1, fillColor=paliTRAQI(qld_SA2s$index) ) 6.1.2 Palettes for continuous variables For the rasters, we used continuous colour scales. leaflet() %&gt;% addTiles() %&gt;% addRasterImage( x=raster_layer ) Since the raster is a grid of values, we donâ€™t need to pass a huge vector of hex codes, but instead we need to pass a function which can take that value and return a hex code. But still, there are options. We could use a binned colour scheme to make an isochrone type map as below. # bins &lt;- c(0, 30, 60, 120, 180, 240, 300, 360, 900, 1200) palBin &lt;- colorBin(&quot;YlOrRd&quot;, domain = 0:1200, bins=bins, na.color=&quot;transparent&quot;) leaflet() %&gt;% addTiles() %&gt;% addRasterImage( x=raster_layer, colors=palBin ) ## Warning in colors(.): Some values were outside the color scale and will be ## treated as NA And our other option is to use a continuous colour scale. palNum &lt;- colorNumeric(&quot;YlOrRd&quot;, domain=0:1200, na.color=&quot;transparent&quot;) leaflet() %&gt;% addTiles() %&gt;% addRasterImage( x=raster_layer, colors=palNum ) ## Warning in colors(.): Some values were outside the color scale and will be ## treated as NA "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
